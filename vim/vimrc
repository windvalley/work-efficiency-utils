" vimrc by @windvalley
" https://raw.githubusercontent.com/windvalley/work-efficiency-utils/master/vim/vimrc


" vim: set foldmarker={{,}} foldlevel=0 foldmethod=marker:
"
" 查看折叠内容的方法:
"    za: 普通模式下按`za`, 表示当光标在关闭折叠上时打开之, 在打开折叠上时关闭之;
"        在打开的折叠内部任意处按`za`, 也会关闭折叠.
"    zA: 是`za`的递归操作, 针对嵌套折叠的场景.


" 安装步骤 {{

" 安装 VIM 及依赖:
"    *** macOS ***
"    brew install cmake python mono go nodejs
"    brew install ctags rg
"    brew install macvim
"
"    *** Linux ***
"    * CentOS7
"    sudo yum -y remove vim-common vim-enhanced vim-filesystem
"    sudo yum -y install gcc-c++ make ncurses ncurses-devel python3 ctags git
"    sudo yum -y install epel-release && yum -y install golang
"    sudo yum -y install mono-devel  # https://www.mono-project.com/download/stable/#download-lin-centos
"    curl -fsSL https://rpm.nodesource.com/setup_15.x | bash -
"    sudo yum -y install nodejs  # node & npm
"    sudo yum -y install tcl-devel ruby ruby-devel lua lua-devel luajit luajit-devel python3 python3-devel perl perl-devel perl-ExtUtils-ParseXS perl-ExtUtils-XSpp perl-ExtUtils-CBuilder perl-ExtUtils-Embed
"    git clone https://github.com/vim/vim.git
"    cd vim
"    ./configure --with-features=huge --enable-multibyte --enable-python3interp --enable-rubyinterp --enable-perlinterp --enable-luainterp
"    make && sudo make install
"
"    * Ubuntu
"    apt install build-essential cmake vim-nox python3-dev
"    apt install mono-complete golang nodejs default-jdk npm

" 注意事项:
"    * VIM 版本要求在 8.1.2269+ 以上, 通过`vim --version`查看.
"    * 为了支持 python3 和复制粘贴的便利, 需要 VIM 支持 python3 和 clipboard, 可通过
"      `vim --version|grep -Eo '\+python3|\+clipboard'`查看是否有相关输出, 没有的话请重新编译安装.
"    * `vimrc`默认集成了 Go 开发插件`vim-go`, 需要系统已经有 Go 环境, 并配置 Go 代理解决墙的问题.
"    * macOS 和 Linux 系统可正常使用, Windows 系统未测试.

" 配置步骤:
" 1. 备份原有的 ~/.vimrc 和 ~/.vim/ 等相关文件和目录:
"    mv ~/.vimrc ~/.vimrc.$(date +%F_%T)
"    mv ~/.vim ~/.vim.$(date +%F_%T)

" 2. 替换你的当前 ~/.vimrc 文件:
"    wget -O ~/.vimrc https://raw.githubusercontent.com/windvalley/work-efficiency-utils/master/vim/vimrc

" 3. 安装用于管理 VIM 插件的插件`vim-plug`:
"    curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

" 4. 安装 vimrc 中已配置的 VIM 插件:
"    vim +PlugInstall +qa

" 5. 配置代码自动补全提示插件YCM:
"    cd ~/.vim/plugged/YouCompleteMe/
"    python3 install.py --all

" 6. `crontab -e`报错的问题解决(如果没有该错误, 忽略该步骤即可):
"    echo 'export EDITOR=vim' >> ~/.zshrc
"    source ~/.zshrc

" }}


" 基础环境配置 {{

" 关闭兼容模式, 也就是不再兼容VI, 必需放在第一行
set nocompatible

" VIM记住多少次历史操作.
set history=1000

" 基于文件类型区别对待插件和缩进,
" 比如对于 .go 文件, 按tab键将显示tab字符`<---`, 其他类型文件, 按tab键显示4个空格`----`
filetype plugin indent on

" 重新设置 map leader 键, 即普通模式下一些VIM命令的prefix, 由默认的`/`改为`,`
let mapleader = ","

" }}


" 插件安装 {{

" 需要先安装用于管理Vim插件的插件: vim-plug
" 系统命令行下:
" curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
"    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
"
" 下面每一个 Plug 对应一个 VIM 插件, 插件名称就是相应 github 项目名称,
" 可通过访问`https://github.com/插件名称`来查看相关插件的详细使用文档;
" 也可以通过命令行模式`:help 插件名称`来查看相关插件文档, 注意这里插件名称不包括插件作者名字和`/`.
call plug#begin('~/.vim/plugged')

" ********************** VIM 主题 ********************************************
" 集成了900多种流行的VIM颜色主题的插件, 包括有名的molokai主题,
" 可在~/.vim/plugged/vim-colorschemes/colors/目录下查看主题名称,
" 一个文件一个主题, 也可以通过命令行方式`:colorscheme `,
" 然后`ctrl+d`查看支持的主题名称, 比如要启用molokai主题,
" 则在本.vimrc文件中配置: colorscheme molokai,
" 当然也可以在命令行模式进行主题切换, 即时看到颜色效果: `:colorscheme shine`.
Plug 'flazz/vim-colorschemes'

" ********************** 代码检查 ********************************************
" https://github.com/dense-analysis/ale
" ALE (Asynchronous Lint Engine) is a plugin providing linter(syntax checking and semantic errors)
" 保存文件时将自动进行静态检查, 有错误将给出高亮提示, 如果配置了修复工具, 也可进行自动修复.
Plug 'dense-analysis/ale'

" ********************** 代码补全 ********************************************
" NOTE: 安装完该插件后或在使用`:PlugUpdate`更新完所有插件后, 需要手动做如下工作:
"    cd ~/.vim/plugged/YouCompleteMe/; python3 install.py --all
Plug 'ycm-core/YouCompleteMe'

" ********************** GUI *************************************************
" 命令行模式下`:NERDTree`, 则在左侧显示目录树窗口, 再次执行隐藏窗口,
" 已映射为快捷键: `,w`
Plug 'scrooloose/nerdtree'
" 使多个标签页共享目录树窗口的插件
Plug 'jistr/vim-nerdtree-tabs'
" 目录树支持git插件
Plug 'Xuyuanp/nerdtree-git-plugin'

" 为正在编辑的文件生成大纲视图, 包括接口/方法/变量等,
" 可选中快速跳转, 适合当个文件代码较多的场景.
" 先在系统命令行安装ctags, 比如如果是macOS系统, 则: brew install ctags
" 命令行模式下`:Tagbar`, 则右边栏显示视图, 再次`:Tagbar`隐藏,
" 已映射为快捷键来方便操作: `,e`
Plug 'majutsushi/tagbar'

" 深度集成git的插件
Plug 'tpope/vim-fugitive'
" git commit浏览插件, 该插件依赖vim-fugitive插件.
"    `:GV` 命令行模式下打开commit浏览, 这个包含当前git repo的所有commit;
"    `:GV!` 这个只看当前文件的commit历史;
"    `o`或`O`或回车, 打开光标所在commit;
"    `q`, 命令模式下退出commit浏览.
Plug 'junegunn/gv.vim'
" 标记通过git管理的文件的变化, 文件左侧会通过显示 +(添加) 或 -(删除) 或 ~(变更) 来提示文件变化.
"    `]c`普通模式下光标跳到后一个变化处,
"    `[c`普通模式下光标跳到前一个变化处.
Plug 'airblade/vim-gitgutter'

" 美化状态栏插件.
Plug 'itchyny/lightline.vim'

" 彩虹括号插件, 层级较多的括号场景使用不同颜色区分.
Plug 'luochen1990/rainbow'

" 缩进线插件.
Plug 'Yggdroot/indentLine'

" ********************** 编程语言 ********************************************
"""""""" Go
" 搭建 Go 开发环境的 VIM 插件, 安装该插件的过程中, 会自动安装该插件依赖的大量 Go 二进制工具,
" 如果由于 Go 环境等问题导致自动安装失败, 可后续通过 VIM 的命令行模式安装`:GoInstallBinaries`.
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }

"""""""" python
Plug 'python-mode/python-mode', { 'for': 'python', 'branch': 'develop' }

"""""""" openresty
" 提供 nginx/openresty 语法高亮与指令补全.
Plug 'spacewander/openresty-vim'

"""""""" javascript/html/css/vue
" 前端利器 html/css/js
Plug 'mattn/emmet-vim'
" 格式化 js, html, css
Plug 'maksimr/vim-jsbeautify'
" Vue 语法高亮插件, 注意会拖慢 VIM, 需要配置这条来解决: `let g:vue_pre_processors = []`
Plug 'posva/vim-vue'

"""""""" markdown
" 基本用法:
"   [[ 跳转上一个标题
"   ]] 跳转下一个标题
"   zr 打开下一级折叠
"   zR 打开所有折叠
"   zm 折叠当前段落
"   zM 折叠所有段落
"   :Toc 显示目录
Plug 'plasticboy/vim-markdown'
Plug 'iamcco/mathjax-support-for-mkdp'
" 打开浏览器预览markdown文本的插件.
Plug 'iamcco/markdown-preview.vim'

"""""""" toml
Plug 'cespare/vim-toml'

" ********************** 效率相关 ********************************************

" 快速打开想要的文件, 类似grep搜索文件内容等, 替代ctrlp插件.
Plug 'Yggdroot/LeaderF', { 'do': ':LeaderfInstallCExtension' }

" 方便注释的插件, 普通模式下或可视模式下:
" `, c <space>` 注释或取消注释选中的代码.
Plug 'preservim/nerdcommenter'

" 普通模式下通过快捷键`,,w`, 将显示光标后的可见内容的各种字母高亮显示,
" 然后输入相关高亮字符组合, 光标会跳转到相关位置.
Plug 'easymotion/vim-easymotion'

" 使用指定符号(比如'等)包围光标所在单词,
"    `ys2w"`, 表示从光标位置开始的2个单词使用"包围;
"    `ds"`, 普通模式下删除光标周围的双引号";
"    `cs"'`, 普通模式下把光标所在周围的双引号"替换为单引号'.
Plug 'tpope/vim-surround'

" 自动补全引号(单引号/双引号/反引号)、括号(()[]{})的插件.
Plug 'Raimondi/delimitMate'


" 最后命令行模式下执行`:PlugInstall`自动安装上面未安装的插件;
" 查看状态: `:PlugStatus`, 查看当前状态, 安装进度等;
" 更新插件: `:PlugUpdate`, 更新所有插件, 建议定期更新所有插件;
" 删除插件: `:PlugClean`, 卸载插件, 需要先在上面注释掉或删除相关插件, 然后重新打开此文件执行此命令;
" 更新 vim-plug 本身: `:PlugUpgrade`.
call plug#end()

" }}


" 主要配置 {{

"""""""" 代码自动补全配置 {{

"""""" ycm-core/YouCompleteMe 配置
" doc: https://github.com/ycm-core/YouCompleteMe

" gd 跳转到函数定义处, 然后可以通过 ctrl o/i 来回跳转;
" 支持的文件类型:
"    c, cpp, objc(object-c), objcpp, cuda, cs(c#), go, java, javascript, python, rust, typescript
"    NOTE: gd 快捷键已被 go-vim 插件的配置占用来实现类似能力, 此处的配置对 Go 不起作用.
"
" 如果 ycm_goto_buffer_command 设置了非 same-buffer 的值, 默认是在窗口上方分屏跳转.
"map gd :YcmCompleter GoTo<CR>
" 新打开标签页的方式跳转, 需要 ycm_goto_buffer_command 设置非 same-buffer 的值, 否则不会打开新的标签页.
map gd :tab YcmCompleter GoTo<CR>
" 右侧分屏的方式跳转, 需要 ycm_goto_buffer_command 设置非 same-buffer 的值, 否则不会分屏跳转.
"map gd :rightbelow vertical YcmCompleter GoTo <CR>

" gr 跳转到引用当前光标所在对象的位置, 会列出引用光标所在对象的所有文件,
" 然后我们选择一个文件名回车, 即可跳转到引用位置.
" 支持的文件类型:
"    c, cpp, objc, objcpp, cuda, java, javascript, python, typescript, rust, 官方没写支持Go, 但实测支持Go.
map gr :YcmCompleter GoToReferences<CR>

" 以什么方式打开 gd 命令跳转的位置.
" Default: 'same-buffer'
"    'same-buffer': 覆盖当前窗口;
"    'split-or-existing-window': 如果要跳转的位置之前已经打开了一个标签页,
"                                就直接跳转到那个已经打开的页面, 否则新打开一个标签页;
"    'split': 不管要跳转的位置之前有没有已经打开了, 都再新打开一个标签页.
let g:ycm_goto_buffer_command = 'split-or-existing-window'

" 基于语义补全的快捷键:
" 语义补全非字符补全, 字符补全是根据当前所有 buffer 中收集到的符号来提示,
" 符号补全只有一个符号名, 不能像语义补全一样给出参数格式, 返回值等丰富信息;
"
" 默认是用 CTRL+SPACE 来触发语义补全的, 中文操作系统下,
" CTRL+SPACE 被系统劫持用作输入法切换, 无法正确传到终端, 所以需要自定义 CTRL+l,
" 有了这个快捷键, 就解决了只能通过`.`号来触发语义补全的局限性了.
let g:ycm_key_invoke_completion = '<c-l>'

" 自动语义补全配置, 无需按 ctrl l 即可自动做语义补全提示:
" 默认的 . / -> / :: 语义补全触发符号是不会被覆盖的, 只会追加成新的 trigger,
" 这里我们追加了一个正则表达式, 代表相关语言的源文件中, 用户只需要输入1个字母, 即可自动弹出语义补全.
let g:ycm_semantic_triggers =  {
\    'go,python,lua': ['re!\w{1}'],
\    'javascript,typescript': ['re!\w{1}'],
\    'c,cpp,java,rust,erlang,perl,perl6': ['re!\w{1}'],
\ }

" 默认值: 0
" 表示是否将你的编码进行记录, 用来在后续的编码过程中进行相关的补全提示.
let g:ycm_seed_identifiers_with_syntax = 1

" 默认值: 2
" 从键入第几个字符开始进行自动匹配提示.
let g:ycm_min_num_of_chars_for_completion = 1

" 默认值: 0
" 是否从注释中输入时也能补全.
let g:ycm_complete_in_comments = 1

" 默认值: 1
" 是否在字符串中输入时也能补全.
let g:ycm_complete_in_strings = 1

" 默认值: 0
" 注释和字符串中的文字是否也被收入到补全数据库中.
let g:ycm_collect_identifiers_from_comments_and_strings = 1

" 默认值是: CursorHold, 表示光标停留在函数一小会儿后自动展示文档;
" 如果值为空, 则表示禁用此功能.
let g:ycm_auto_hover = 'CurorHold'
" 设置此 map 后, 上面的 let g:ycm_auto_hover = 'CurorHold' 功能自动失效, 需要通过`,D`来触发文档显示.
nmap <leader>D <plug>(YCMHover)

" 默认值: 1
" 是否启用 YCM 提供的代码静态检查功能, 由于我们使用了 ale 来做静态代码检查, 所以这里禁用.
let g:ycm_show_diagnostics_ui = 0
let g:ycm_error_symbol = '>>'
let g:ycm_warning_symbol = '>'
""""""""""""""""""""""""""

" }}

"""""""" 代码静态检查配置 {{

" ale用于替代syntastic插件.
" NOTE: `:ALEInfo`, 用于查看当前文件的语法检查配置情况,
" 内容尾部是对当前文件内容执行检查的日志, 可通过这些日志排查问题.
" doc: https://github.com/dense-analysis/ale

" 定制显示在行左侧的错误提示符和警告提示符.
" 默认值: '>>'
let g:ale_sign_error = '>>'
" 默认值: '--'
let g:ale_sign_warning = '--'

" 左侧的错误/警告提示列是否一直保持打开.
" 默认值: 0
let g:ale_sign_column_always = 0

" 用于错误或警告提示的字符串.
" 默认值: 'Error'
let g:ale_echo_msg_error_str = 'Error'
" 默认值: 'Warning'
let g:ale_echo_msg_warning_str = 'Warning'

" 设置提示信息的输出格式.
" 默认值: '%code: %%s'
let g:ale_echo_msg_format = '[%linter%] %code: %%s [%severity%]'

" 新打开文件时是否lint.
" 默认值: 1
let g:ale_lint_on_enter = 1

" 保存文件时是否进行lint.
" 默认值: 1
let g:ale_lint_on_save = 1

" 保存文件时是否进行fix.
" 默认值: 0
let g:ale_fix_on_save = 1

" 使用 ctrl k/j 在错误提示之间跳转.
nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)

" NOTE:
" 其他没有在这里配置的语言将使用ale默认配置的linter,
" 可以使用`:ALEInfo`来查看当前文件使用了哪些默认的linter.
"
" 注意需要在本地安装涉及到的命令行工具:
"   brew update
"   brew install golangci-lint lua luarocks tidy-html5 shellcheck jq
"   luarocks install luacheck
"   npm install -g eslint standard eslint-plugin-vue vls \
"       proselint alex write-good stylelint markdownlint jsonlint
"   pip3 install pylint flake8 yamllint
"   go get github.com/golangci/golangci-lint/cmd/golangci-lint@v1.39.0
"   go get -u github.com/mgechev/revive
"   sudo gem install mdl
"
" eslint配置文件, 项目根目录下的.eslintrc.json, 需要通过如下命令生成, 我们这里使用standard风格:
"   eslint --init
"   或 vue create project-demo(需要选择手动配置, 选择standard风格), 将配置生成到package.json的eslintConfig字段.
" prettier配置文件, 项目根目录下的.prettierrc.json:
"    {
"      "singleQuote": true,
"      "semi": false
"    }
"
" 对于Python项目, 如果使用虚拟环境, 需要在虚拟环境下安装相关lint工具, 拿poetry依赖工具举例:
"    poetry init
"    poetry shell
"    poetry add pylint flake8 autoimport black isort -D
let g:ale_linters = {
\    'go': ['golangci-lint', 'revive'],
\    'python': ['pylint', 'flake8'],
\    'lua': ['luac', 'luacheck'],
\    'sh': ['shellcheck'],
\    'javascript': ['eslint', 'standard'],
\    'vue': ['eslint', 'vls'],
\    'html': ['tidy', 'stylelint', 'alex', 'writegood', 'proselint'],
\    'yaml': ['yamllint'],
\    'json': ['jq', 'jsonlint'],
\    'markdown': ['mdl', 'markdownlint', 'proselint', 'alex'],
\}

" 覆盖掉~/.vim/plugged/ale/ale_linters/go/golangci_lint.vim中的个别默认配置.
" golanci-lint run 命令不加额外参数, 解决默认加的--enable-all参数导致的错误.
call ale#Set('go_golangci_lint_options', '')
" golangci-lint run 命令以包为单位进行检查, 解决默认以文件方式检查时的typecheck错误误报的问题.
call ale#Set('go_golangci_lint_package', 1)

" 安装相关的命令行工具:
"   npm install -g prettier importjs lua-fmt
"   pip3 install black isort
"   go get mvdan.cc/sh/v3/cmd/shfmt
" prettier等工具自身就有trim_whitespace和remove_trailing_lines的能力, 所以不用重复添加.
"
" 注意:
" 不要使用python的autoimport工具, 重新排版的import可能发生错误;
" 用于python的isort, 可选择性使用, 我这里也不启用, 直接用black的import排版能力即可.
let g:ale_fixers = {
\    'python': ['black', 'add_blank_lines_for_python_control_statements'],
\    'lua': ['luafmt', 'trim_whitespace', 'remove_trailing_lines'],
\    'sh': ['shfmt'],
\    'javascript': ['eslint', 'importjs'],
\    'vue': ['eslint'],
\    'html': ['prettier'],
\    'json': ['jq'],
\    'yaml': ['prettier'],
\    'markdown': ['prettier'],
\}

" }}

"""""""" 目录树相关配置 {{

"""""" NERDTree插件的配置
" 普通模式下显示或隐藏目录树的快捷键: `,w`
map ,w :NERDTreeToggle<CR>

" 系统命令行直接运行 vim 的时候(不接任何文件), 自动打开目录树.
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

" 目录树中目录折叠与展开的箭头表示, 默认是▸和▾
let g:NERDTreeDirArrowExpandable = '▸'
let g:NERDTreeDirArrowCollapsible = '▾'

" 设置目录树窗口宽度.
let NERDTreeWinSize=30

" nerdtree-git-plugin的配置
let g:NERDTreeGitStatusIndicatorMapCustom = {
    \ "Modified"  : "✹",
    \ "Staged"    : "✚",
    \ "Untracked" : "✭",
    \ "Renamed"   : "➜",
    \ "Unmerged"  : "═",
    \ "Deleted"   : "✖",
    \ "Dirty"     : "✗",
    \ "Clean"     : "✔︎",
    \ 'Ignored'   : '☒',
    \ "Unknown"   : "?"
\ }

" 标签页切换快捷键: 普通模式下`shift+h`向左, `shift+l`向右
map <S-h> gT
map <S-l> gt

" 是否显示隐藏文件
" Default: 0
let NERDTreeShowHidden=1

" 忽略文件的显示, 开启这个将默认显示隐藏文件.
let NERDTreeIgnore=['\.pyc$','__pycache__','\.swp$']

" 是否显示目录树的行号
" Default: 0
let NERDTreeShowLineNumbers=0

" 打开文件时, 自动显示目录树
"autocmd vimenter * NERDTree

" 如果文件都退出了, 只剩目录树窗口的情况下自动退出vim.
"autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.istabTree()) | q | endif

" NERDTree窗口常用快捷键介绍(普通模式下):
" 1. `Ctrl+ww`会在目录树窗口和其他窗口之间来回切换光标;
" 2. j向上移动光标, k向下移动光标, h向左移动光标, l键向右移动光标,
"    按回车键或o键展开目录或打开文件;
" 3. 如果光标选择文件后直接回车或o键的话, 将在原文件窗口打开新文件,
"    视觉上覆盖掉了原文件, 所以建议光标移到某个文件后按t键,
"    这样将以新标签的形式打开文件, T键则是静默的打开(光标不切换过去);
" 4. 如果有多个文件标签, `gt`将向后切换文件, `gT`将向前切换文件,
"    已设置了快捷键映射, 可通过`Shift+l`和`shift+h`切换;
"""""""""""""""""""

"""""" Tagbar插件配置
" 普通模式下显示或隐藏大纲视图的快捷键: `,e`
nmap ,e :TagbarToggle<CR>

" 设置Tagbar窗口宽度
let g:tagbar_width = 30

" 开启自动预览,
" 随着光标在tabar窗口中的标签上移动, 代码窗口顶部会出现一个实时的代码预览窗口.
let g:tagbar_autopreview = 1

" 关闭排序, 即按标签本身在代码文件中的位置排序.
let g:tagbar_sort = 0
"""""""""""""""""""

"""""" itchyny/lightline.vim 配置
" 本选项的值影响最后一个窗口何时有状态行:
"     0: 永不
"     1: 只有在有至少两个窗口时
"     2: 总是
" 默认值: 1
" 为了单窗口也可以显示状态栏, 此处设置为2.
set laststatus=2

" 由于此插件已经帮我们美化显示了当前的 VIM 模式, 所以 VIM 自带的模式显示可以去除.
set noshowmode

" 定制状态栏的主题颜色.
" doc: https://github.com/itchyny/lightline.vim
let g:lightline = {
\ 'colorscheme': 'solarized',
\ }
"""""""""""""""""""""""""""

"""""" Yggdroot/indentLine 插件配置
" 是否显示缩进线.
" 默认值: 1
let g:indentLine_enabled = 1

" 自定义缩进线样式.
" 默认值: '¦'
let g:indentLine_char = '¦'

" 不同层级显示不同的缩进线.
" 默认值: []
let g:indentLine_char_list = ['¦', '┆', '┊']

" 缩进线的颜色定义
let g:indentLine_defaultGroup = 'SpecialKey'
"""""""""""""""""""""""""""

" }}

"""""""" 效率相关 {{

"""""" Yggdroot/LeaderF 插件配置
" 需要在系统上提前安装 rg 命令: brew install rg
" doc: https://github.com/Yggdroot/LeaderF

" normal模式下 ff  进入文件搜索的 模糊搜索方式;
" 再 ctrl r  进入 正则匹配 方式;
let g:Lf_ShortcutF = "ff"

" 显示最近打开过的文件列表.
noremap <leader>fm :<C-U><C-R>=printf("Leaderf mru %s", "")<CR><CR>

" 搜索当前文件的内容.
noremap <leader>fb :<C-U><C-R>=printf("Leaderf buffer %s", "")<CR><CR>
noremap <leader>ft :<C-U><C-R>=printf("Leaderf bufTag %s", "")<CR><CR>
noremap <leader>fl :<C-U><C-R>=printf("Leaderf line %s", "")<CR><CR>

" 从普通模式下按 rg 进入命令行模式下, 然后输入要搜索的文本(支持正则表达式),
" 回车即可显示此项目内包含此文本的文件列表;
" 在弹出的结果窗口中, 按 gi 可以将光标移动到输入框, 可以继续输入内容缩小结果列表,
" 然后按 tab 进入结果列表中, 按 j/k 上下选择, 选择一个文件后, 按 t 将以新建标签页的方式打开选择的文件.
noremap rg :<C-U><C-R>=printf("Leaderf! rg -e %s ", expand("<cword>"))<CR>

" 可视模式下选择文本后, 按 rg 在整个项目内搜索选择的文本, 显示搜索结果.
xnoremap rg :<C-U><C-R>=printf("Leaderf! rg -F -e %s ", leaderf#Rg#visual())<CR><CR>

" rg 搜索内容关闭后, 想再次搜索上次是搜索的内容, 普通模式下按 rc 即可.
noremap rc :<C-U>Leaderf! rg --recall<CR>

" 弹出独立的窗口来显示搜索文件.
let g:Lf_WindowPosition = 'popup'
" 弹出的窗口占终端的百分比, 0.8 即80%.
let g:Lf_PopupWidth = 0.8
let g:Lf_PreviewInPopup = 1

" }}

"""""""" Go {{

" 在安装完vim-go插件的前提下, 命令行模式下`:w`保存文件时将自动import和gofmt.
let g:go_fmt_command = "goimports"

let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_structs = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1

" 查看光标所在函数等的简要信息
au FileType go nmap <Leader>i <Plug>(go-info)
" 上下分屏查看光标所在函数等的文档
au FileType go nmap <Leader>d <Plug>(go-doc)
" 左右分屏查看光标所在函数等的文档
au FileType go nmap <Leader>dv <Plug>(go-doc-vertical)
" go run 当前的go文件
au FileType go nmap <leader>r <Plug>(go-run)
" go build 当前的go文件, 不产生二进制文件, 只是检查是否可以成功build
au FileType go nmap <leader>b <Plug>(go-build)
" 查看光标所在的类型实现了哪些接口, 注意光标只能在类型或类型的方法上
au FileType go nmap <Leader>s <Plug>(go-implements)
" 查看有哪些地方调用了光标所在的函数, 从弹出的列表中选择一个, 然后回车, 将跳转到调用位置
au FileType go nmap <Leader>f <Plug>(go-callers)

" go test 当前的go文件
au FileType go nmap <leader>t <Plug>(go-test)
" 查看当前代码文件的测试覆盖率
au FileType go nmap <Leader>c <Plug>(go-coverage)

" NOTE: Go 跳转到函数定义处的4种方式, 能力均由vim-go插件提供, 和YCM配置无关.
"
" 快捷键1: gd 默认以覆盖当前页面的方式跳转到函数定义处, vim-go插件默认行为, 无需配置.
" 快捷键2: ds 上下分屏跳转到函数定义处
au FileType go nmap ds <Plug>(go-def-split)
" 快捷键3: dv 左右分屏跳转到函数定义处
au FileType go nmap dv <Plug>(go-def-vertical)
" 快捷键4: dt 新开一个标签页的方式跳转到函数定义处
au FileType go nmap dt <Plug>(go-def-tab)
" 以上4条如果光标所在函数定义处就是在当前页面, 则直接在当前页跳转, 并不打开新页面;
" 如果在当前页面内跳转, 推荐使用 ctrl o/i 来回跳转切换, 以提高效率.

" }}

"""""""" Python {{

" 新建.py结尾的文件时, 自动输入一些内容
func SetTitleForPython()
    call setline(1, "\#!/usr/bin/env python3")
    call setline(2, "\"\"\"")
    call setline(3, "Author: windvalley")  " 改成你自己的名字
    call setline(4, "Created Time: ".strftime("%Y-%m-%d %H:%M:%S"))
    call setline(5, "\"\"\"")
    normal G
    normal o
    normal o
    " 为新创建的.py文件自动赋予可执行权限
    au BufWritePost *.py silent !chmod a+x <afile>
endfunc
autocmd bufnewfile *.py call SetTitleForPython()

" 如果一个.py文件开头第一行不是以#!开头, 就去除掉文件的可执行权限.
function! NoShabang(line1, current_file)
  if a:line1 !~ '^#!'
    let chmod_command = "silent !chmod ugo-x " . a:current_file
    execute chmod_command
  endif
endfunction
autocmd BufWritePost *.py call NoShabang(getline(1), expand("%:p"))

"""""" 'python-mode/python-mode'配置
" doc: https://github.com/python-mode/python-mode/blob/develop/doc/pymode.txt

" 专心用YCM, 禁用rope
let g:pymode_rope = 0

" 已经使用ale来做检查, 禁用pymode的检查
let g:pymode_lint = 0

" }}

"""""""" OpenResty/Lua {{
func SetTitleForLua()
    " 自动获取文件名称, 不包含文件扩展名.
    let filename = expand('%:r')
    let lua_module_name = join(["_M.name = \"", filename, "\""], "")

    call setline(1, "local ngx = require \"ngx\"")
    call setline(2, "")
    call setline(3, "")
    call setline(4, "local _M = {}")
    call setline(5, "")
    call setline(6, "_M._VERSION = 0.1")
    call setline(7, lua_module_name)
    call setline(8, "")
    normal G
    normal o
    normal o
endfunc
autocmd bufnewfile *.lua call SetTitleForLua()

" }}

"""""""" Javascript/vue/html/css {{

" css
autocmd FileType css set omnifunc=csscomplete#CompleteCSS

" js/html/vue, 缩进使用2个空格等配置, 已通过ale配置, 此配置注释掉
"au BufNewFile,BufRead *.html,*.js,*.vue set tabstop=2
"au BufNewFile,BufRead *.html,*.js,*.vue set softtabstop=2
"au BufNewFile,BufRead *.html,*.js,*.vue set shiftwidth=2
"au BufNewFile,BufRead *.html,*.js,*.vue set expandtab
"au BufNewFile,BufRead *.html,*.js,*.vue set autoindent
"au BufNewFile,BufRead *.html,*.js,*.vue set fileformat=unix

"""""" maksimr/vim-jsbeautify 配置, 已通过ale设置自动修复, 这里的配置不再使用
" 使用方法:
"   `ctrl+f`, 进行格式化

" 普通模式下, 对文件的全部内容进行格式化
"autocmd FileType javascript noremap <buffer>  <c-f> :call JsBeautify()<cr>
"autocmd FileType json noremap <buffer> <c-f> :call JsonBeautify()<cr>
"autocmd FileType jsx noremap <buffer> <c-f> :call JsxBeautify()<cr>
"autocmd FileType html noremap <buffer> <c-f> :call HtmlBeautify()<cr>
"autocmd FileType css noremap <buffer> <c-f> :call CSSBeautify()<cr>

" 可视模式下选取部分代码进行格式化, 通过在普通模式下按v进入可视模式
"autocmd FileType javascript vnoremap <buffer>  <c-f> :call RangeJsBeautify()<cr>
"autocmd FileType json vnoremap <buffer> <c-f> :call RangeJsonBeautify()<cr>
"autocmd FileType jsx vnoremap <buffer> <c-f> :call RangeJsxBeautify()<cr>
"autocmd FileType html vnoremap <buffer> <c-f> :call RangeHtmlBeautify()<cr>
"autocmd FileType css vnoremap <buffer> <c-f> :call RangeCSSBeautify()<cr>

"""""" posva/vim-vue 插件
" 解决vim-vue插件导致的vim速度变慢
let g:vue_pre_processors = []

"""""" 'mattn/emmet-vim'配置
" 使用方法:
" https://raw.githubusercontent.com/mattn/emmet-vim/master/TUTORIAL
" 1. 打开 *.html 文件, 输入`html:5`, 然后`ctrl y ,`, 即可自动生成html代码模版
" 2. 输入`div`, 然后`ctrl y ,`, 即可自动生成: <div></div>
" 3. 输入`#foo`, 然后`ctrl y ,`, 可自动生成: <div id="foo"></div>
" 4. 输入`div>p>a`, 然后`ctrl y ,`, 可自动生成: <div><p><a href=""></a></p></div>

" Enable just for html/css
let g:user_emmet_install_global = 0
autocmd FileType html,css EmmetInstall

" 默认值: <C-y>
let g:user_emmet_leader_key='<C-y>'

" }}

"""""""" Shell {{

func SetTitleForShell()
    let current_filename = expand('%:t')
    call setline(1, "\#!/usr/bin/env bash")
    call setline(2, "# " . current_filename)
    call setline(3, "#")
    "call setline(4, "# Author: windvalley") " 改成你自己的名字
    "call setline(5, "# Created Time: ".strftime("%Y-%m-%d %H:%M:%S"))
    call setline(4, "")
    normal G
    normal o
    normal o
    " 为新创建的.sh文件自动赋予可执行权限
    au BufWritePost *.sh silent !chmod a+x <afile>
endfunc
autocmd bufnewfile *.sh call SetTitleForShell()

" }}

"""""""" Markdown {{

" :help vim-markdown
let g:vim_markdown_math = 1
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_toml_frontmatter = 1
let g:vim_markdown_frontmatter = 1
let g:vim_markdown_json_frontmatter = 1
let g:vim_markdown_new_list_item_indent = 2
let g:vim_markdown_autowrite = 1
" 在超链接处, 按ge将以新标签页的形式打开链接
let g:vim_markdown_edit_url_in = 'tab'
let g:vim_markdown_emphasis_multiline = 0
"let g:vim_markdown_no_extensions_in_markdown = 1
"let g:vim_markdown_auto_extension_ext = 'txt'

" :help markdown-preview
let g:mkdp_path_to_chrome = "open -a Google\\ Chrome"
nmap ,p :MarkdownPreview<CR>
nmap ,pp <Plug>StopMarkdownPreview

" 1. 通过命令行检查和自动修正markdown文件
" npm install -g markdownlint-cli
" 检查: markdownlint foo.md
" 修复: markdownlint -f foo.md
" 2. mdl工具, 无自动修复功能
" sudo gem install mdl
" mdl foo.md
" mdl -l

" }}

" }}


" 自定义配置 {{

" 解决中文乱码问题.
let $LANG='en'
set langmenu=en
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim
" 设置 utf8 为标准编码, en_US 为标准语言.
set encoding=utf8

" ,) / ,] / ,} / ," / ,' / ,` 将可视模式下选择的内容使用 () 或 [] 或 {} 或 "" 或 '' 或 `` 包裹.
vnoremap <leader>) <esc>`>a)<esc>`<i(<esc>
vnoremap <leader>] <esc>`>a]<esc>`<i[<esc>
vnoremap <leader>} <esc>`>a}<esc>`<i{<esc>
vnoremap <leader>" <esc>`>a"<esc>`<i"<esc>
vnoremap <leader>' <esc>`>a'<esc>`<i'<esc>
vnoremap <leader>` <esc>`>a`<esc>`<i`<esc>

" 插入模式下移动光标的快捷键:
"   `ctrl f` 右, `ctrl b` 左, `ctrl p` 上, `ctrl n` 下,
"   `ctrl a` 行首, `ctrl e` 行尾.
inoremap <C-f> <Right>
inoremap <C-b> <Left>
inoremap <C-p> <Up>
inoremap <C-n> <Down>
imap <C-a> <Home>
imap <C-e> <End>

" 普通模式下, 使用Y复制当前行光标之后的内容, 和C和D用法统一起来.
nnoremap Y y$

" 普通模式下`shift >>`和`shift <<`或可视模式下`shift >`和`shift <`每次缩进4个空格, 默认是8个空格.
set shiftwidth=4
" 可视模式下进行`shift >`和`shift <`缩进操作时, 使不退出可视模式, 这样可方便执行多行的连续缩进.
vnoremap < <gv
vnoremap > >gv

" 重新打开文件时, 光标恢复在上次离开时的位置.
augroup resCur
    autocmd!
    autocmd BufReadPost * call setpos(".", getpos("'\""))
augroup END

" 插入模式下使用 <BS> <Del> <C-W> <C-U>, 解决无法回退删除等问题, 比如按 backspace 键无反应.
set backspace=indent,eol,start
set whichwrap+=<,>,h,l

" `:W`, 普通用户没有权限时使用 sudo 保存文件.
command! W execute 'w !sudo tee % > /dev/null' <bar> edit!

" 打开文件监视, 在修改内容后 :wq,  如果文件已经被其他 VIM 实例打开,
" 则会进行提示, 如果忽略提示强制进行保存, 则其他 VIM 实例打开的此文件也会同步变更.
set autoread
au FocusGained,BufEnter * checktime

" 保留撤销历史, VIM会在编辑时保存操作历史, 用来供用户撤消更改;
" 默认情况下, 操作记录只在本次编辑时有效, 一旦编辑结束、文件关闭, 操作历史就消失了;
" 打开这个设置, 可以在文件关闭后, 操作记录保留在一个文件里面, 继续存在.
" 这意味着, 重新打开一个文件, 可以撤销上一次编辑时的操作;
" 撤消文件是跟原文件保存在一起的隐藏文件, 文件名以.un~开头.
set undofile
set undodir=~/.vim/undo
if !isdirectory(&undodir)
  call mkdir(&undodir, 'p', 0700)
endif

" 普通模式下的`nyy`复制(n为数字), 或进入可视模式下选择内容后的`y`复制,
" 除了可以将复制的内容粘贴(使用`p`)到其他 VIM 实例,
" 还可以将内容粘贴(`command v`)到系统的其他任何可输入窗口.
"
" 注意: 以上所说的都是针对本地操作系统使用本地 VIM 的情况,
" 比如 macOS/Windows/Linux 本地的 VIM 和本地的其他应用窗口之间,
" 不包括远程连接的操作系统的 VIM 和本地应用的窗口之间.
if has('clipboard')
    if has('unnamedplus')
        set clipboard=unnamed,unnamedplus " for Linux
    else
        set clipboard=unnamed " for macOS、Windows
    endif
endif

" 此配置确保在非图形界面的终端, 且终端类型不是 xterm 的情况下,
" 只能在 c v i 三种模式下使用鼠标, 也就是在普通模式(n)下禁用鼠标,
" 这样当用户在普通模式下时, VIM 将不对鼠标进行响应,
" 这样就可以使用鼠标复制 VIM 窗口里的内容到其他应用程序里去了.
"
" 注意: 这里的配置适合使用 macOS 自带的 terminal 的场景,
" 如果使用的是 iterm2, 则不需要这段配置也能正常使用.
if has('mouse')
  if has('gui_running') || (&term =~ 'xterm' && !has('mac'))
    set mouse=a  " a 表示全部 VIM 模式下都可以使用鼠标.
  else
    set mouse=vic  " 只在命令模式(c)、可视模式(v)、插入模式(i)中使用鼠标.
  endif
endif

" }}


" 常用配置 {{

" 启用颜色主题方案,
" 常用方案备选: molokai, solarized, peaksea, ir_black
" 其他主题名称见~/.vim/plugged/vim-colorschemes/colors/, 文件名即主题名.
colorscheme solarized

" 代码高亮显示.
syntax enable

" 显示行号.
set nu
" 设置行号颜色.
hi LineNr cterm=NONE ctermbg=NONE ctermfg=238 guibg=NONE guifg=NONE

" 设置 提示列 的颜色方案;
" 比如 ale 插件的代码静态检查的错误或警告信息就会出现在此列, 
" gitgutter 插件的文件变化信息也会出现在此列.
hi SignColumn cterm=NONE ctermbg=NONE ctermfg=NONE guibg=NONE guifg=NONE

" 突出显示当前行.
set cursorline
" 可在使用 molokai 主题时选择开启.
"hi CursorLine cterm=NONE ctermbg=234 ctermfg=NONE guibg=NONE guifg=NONE

" 突出显示当前列.
set cursorcolumn
" 可在使用 molokai 主题时选择开启.
"hi Cursorcolumn cterm=NONE ctermbg=234 ctermfg=NONE guibg=NONE guifg=NONE

" tab 键显示为 >---, 行尾空格显示为 -, 帮助我们及时发现规范问题.
set list listchars=tab:>-,trail:-
" 非可见字符nbsp、tab、trail是由SpecialKey高亮组来定义的,
" 所以这里使用SpecialKey来改变tab键和行尾空格的颜色样式.
hi SpecialKey cterm=NONE ctermbg=NONE ctermfg=238 guibg=NONE guifg=NONE

" 第80列通过颜色标注, 提示我们对单行代码长度的掌控.
autocmd FileType * set colorcolumn=80
" 可在使用 molokai 主题时选择开启.
"hi colorcolumn  cterm=NONE ctermbg=236 ctermfg=NONE guibg=NONE guifg=NONE

" 普通模式下允许光标移动到最后一个字符的右边.
set virtualedit=onemore

" 显示括号匹配.
set showmatch

" 普通模式下显示输入的 VIM 命令.
set showcmd

" 底部命令模式的显示高度, 默认值1.
set cmdheight=1

" 一个 tab 显示几个空格长度, 默认是8个空格, 这里改为4个空格.
set ts=4
" 将 tab 缩进用空格来表示, 提高效率.
set expandtab

" 插入模式下按退格键的时候退回缩进的长度为4个空格, 默认是退回一个空格.
set softtabstop=4

" 启用智能缩进, 按回车键后自动缩进, 注意启用此模式后, 粘贴代码时要先在命令行模式下`:set paste`.
set smartindent

" 显示当前光标所在的行号和列号.
set ruler

" 进行搜索时会快速找到结果, 随着输入的字符进行及时匹配.
set incsearch
" 搜索关键字高亮显示.
set hlsearch
" 搜索时忽略大小写.
set ignorecase
" 如果同时打开了ignorecase, 那么对于搜索只有一个大写字母的搜索词, 将大小写敏感;
" 其他情况都是大小写不敏感, 比如: 搜索 Test 时, 将不匹配 test, 但搜索 test 时, 将匹配 Test.
set smartcase

" 不创建备份文件. 默认情况下, 文件保存时, 会额外创建一个备份文件,
" 它的文件名是在原文件名的末尾, 再添加一个波浪号(〜).
set nobackup

" 出错时不要发出响声.
set noerrorbells

" 命令行模式下, 操作指令按下 tab 键自动补全:
" 第1次按下 tab, 会显示所有匹配的操作指令的清单, 第2次按下 tab, 会依次选择各个指令.
set wildmenu
set wildmode=longest:list,full

" 如果过了这么多毫秒数以后还没有任何输入, 把交换文件写入磁盘, 也用于 CursorHold 自动命令事件.
" 默认值: 4000(毫秒)
set updatetime=1000

" 打字的时候隐藏鼠标光标.
set mousehide

" 当一行字符长度超过多少个字符时, 会自动换行, 注意会加上换行符;
" 我这里配置这个的目的是解决 .vimrc 的注释内容超过80个字符就自动换行的问题.
set textwidth=1000

" }}


" 备用配置 {{

" 输入的文字到达终端边缘时不自动折行, 所谓折行指的是一行内容视觉上显示为多行,
" 不是真正的加换行符的换行.
"set nowrap

" 保存文件时自动去除行尾空格, 注意已经通过ale配置, 此条注释不再使用.
"autocmd BufWritePre *.sh,*.lua,*.js,*.html,*.vue,*.toml,*.yaml,*.yml :%s/\s\+$//e

" 退出插入模式时指定类型的文件将自动保存.
"au InsertLeave *.go,*.lua,*.sh,*.py,*.js,*.md write

" 退出文件后, 屏幕依然显示该文件内容.
"set t_ti= t_te=

" 显示标签页.
"set tabpagemax=20
"set showtabline=2

" 显示状态栏.
"set laststatus=2

" 打开英语单词的拼写检查.
"set spell spelllang=en_us

" 覆盖掉默认的拼写检查设置, 不启用拼写检查.
"autocmd VimEnter * set nospell

" 不创建交换文件, 交换文件主要用于系统崩溃时恢复文件, 文件名的开头是`.`, 结尾是 `.swp`.
"set noswapfile

" 出错时, 发出视觉提示, 通常是屏幕闪烁.
"set visualbell

" }}


" 使用技巧 {{

"""""""""" VIM 常用命令行 {{
"
" vim -u NONE                   无插件方式运行 VIM.
" vim -g/mvim/gvim  macOS       下运行 VIM 的图形界面模式, 需先安装 macvim.
" vim -V9myVIM.log              将 VIM 运行的详细日志保存到 myVIM.log 文件中.
" vim --startuptime vim.log     记录带时间的启动日志.
" vim -c 'normal 5G36|'         来执行跳转到第5行第36列.
" vimtutor                      VIM 自带的学习教程.
"
" }}

"""""""""" VIM 常用的原生能力 {{
"
" ** 文本对象的快捷编辑:
"
" 命令涉及到的常用字符说明:
"                  y  表示复制.
"                  v  表示选择, 选择后进入可视模式.
"                  d  表示删除.
"                  c  表示替换, 这里的替换表示删除文本对象后进入插入模式.
"                  x  表示剪切.
"                  l  表示光标右侧1个字符.
"                  h  表示光标左侧1个字符.
"                  w  表示光标右侧1个单词.
"                  b  表示光标左侧1个单词.
"                  W  表示光标右侧1个单词, 这里的单词可以包含特殊符号, 也就是以空格为单词分隔符.
"                  i  inside, 表示光标在要操作的文本对象的内部, 操作时不包含边界.
"                  a  量词a, 表示光标在要操作的文本对象的内部, 操作时包含边界, i和a需要实际操作来体会一下, 不太容易讲的明白.
"                  n  表示要操作的文本对象的数量, 不写 n 的话, 默认是1.
"
" 以上字符可按基本规则自由组合:
"       y/v/d/c [n]l  复制/选择/删除/替换光标右 n 个字符, n 可不输入, 默认是1.
"       y/v/d/c [n]h  复制/选择/删除/替换光标左 n 个字符.
"       y/v/d/c [n]w  复制/选择/删除/替换光标右 n 个单词.
"       y/v/d/c [n]W  复制/选择/删除/替换光标右 n 个单词, 特殊字符也作为单词的一部分.
"       y/v/d/c [n]b  复制/选择/删除/替换光标左 n 个单词.
"       y/v/d/c [n]B  复制/选择/删除/替换光标左 n 个单词, 特殊字符也作为单词的一部分.
"        [n]yy/dd/cc  复制/删除/替换 n 行.
"          y/v/d/c 0  从光标位置 复制/选择/删除/替换 到行首.
"          y/v/d/c $  从光标位置 复制/选择/删除/替换 到行尾.
"          di"/(/{/[  删除 "" 或 () 或 {} 等之间的所有字符, 不包括它们本身.
"          da"/(/{/[  删除 "" 或 () 或 {} 等之间的所有字符, 也包括它们本身.
"               c2i(  删除2层 () 内的内容, 只留下一对 (),  并进入插入模式.
"                     还有很多不同组合, 请亲自尝试理解:
"                         yw/yiw/y3w/yW/yi{/ya{/y3i{/yb/yB
"                         vw/viw/v3iw/vW/vi{/va{/v3i{
"                         cw/ciw/c3w/cW/cb/cB
"                         dw/diw/db/dB/d3w
"                  D  删除当前行光标之后的内容.
"                  C  替换当前行光标之后的内容.
"                  Y  复制当前行光标之后的内容. (**自定义配置**)
"               [n]x  剪切光标右测 n 个字符, 同 d[n]l.
"               [n]X  剪切光标左测 n 个字符, 同 d[n]h.
"               [n]s  同 c[n]l.
"               [n]S  同 [n]cc.
"                p/P  在光标 右侧/左侧 粘贴.
"                  r  替换当前光标所在字符.
"                  R  进入替换模式, 每次按键替换一个字符, 直到按 ESC 键退出替换模式.
"                  u  undo, 撤销最近一次的修改动作.
"                  U  撤销当前所在行的所有修改.
"             ctrl r  redo, 恢复最近一次的撤销内容.
"    :n,ms/old/new/g  将文件内第 n 行到第 m 行的所有 old 替换为 new.
"      :%s/old/new/g  将文件内所有 old 替换为 new.
"     :%s/old/new/gc  每个匹配串替换前提示是否进行替换.
"             ctrl o  插入模式下, 使临时进入 normal 模式下, 执行一个 normal 命令就自动再返回插入模式下.
"         ctrl h/w/u  插入模式下, 向左删除 一个字符/一个单词/行首.
"       ,)/]/}/"/'/`  将可视模式下选择的内容使用 () 或 [] 或 {} 或 "" 或 '' 或 `` 包裹. (**自定义配置**)
"
" ** 移动光标:
"               kjhl  上下左右移动光标.
"              gk/gj  对于折行的情况, 向上/向下 在折行间移动光标.
"                w/W  向右移动一个单词位置, 光标在单词开头,
"                     大写表示特殊符号也算单词的组成部分, 可前置数字表示移动的单词数量.
"                e/E  同上, 区别是移动到单词末尾.
"                b/B  向左移动一个单词位置, 光标在单词开头, 其他同 w/W.
"                  0  光标跳转到行首.
"                  ^  光标跳转到行首第一个非空字符.
"                  $  光标跳转到行尾.
"                (/)  移动到上一句/下一句.
"                {/}  移动到上一段落/下一段落.
"                  M  光标移动到当前屏幕的中间行的行首.
"             Ngg/NG  光标移动到第 N 行.
"                 N%  光标移动到 N% 行处.
"                 N|  至第 N 列, 这里的 | 是竖线字符.
"                */#  匹配当前光标所在单词并跳转到下一个单词/上一个单词.
"                 f*  这里的 * 表示的是任意你要跳转到的本行字符, 比如你要跳转到`,`, 则`f,`,
"                     然后按`;`继续向右匹配, 按`,`向左匹配, 直到跳转到自己想去的位置.
"          ctrl bfpn  插入模式下左右上下移动光标. (**自定义配置**)
"           ctrl a/e  插入模式下跳转到行首/行尾. (**自定义配置**)
"           ctrl o/i  将光标跳转到之前/之后的位置.
"           ctrl f/b  向下/向上翻整屏.
"           ctrl d/u  向下/向上翻半屏.
"           ctrl e/y  以一行为单位上下移动屏幕, 而不移动光标.
"           zt/zz/zb  把光标所在行放置到屏幕的顶部、中间、底部.
"
" ** 排版
"              >>/<<  在普通模式下向 右/左 缩进4个空格.
"                >/<  可视模式下向 右/左 缩进4个空格.
"                :ce  本行文字居中(center).
"                :le  本行文字靠左(left).
"                :ri  本行文字靠右(right).
"
" ** 进入 insert 模式的几种方法:
"                  i  在当前光标位置插入.
"                  I  在当前行第一个非空字符前插入.
"                 gI  在行首插入.
"                  a  光标向右移动一个位置.
"                  A  光标跳转到行尾插入.
"                  o  向下新建一行插入.
"                  O  向上新建一行插入.
"
" ** 进入几种不同的 visual 模式:
"                  v  进入 visual 模式.
"                  V  进入 visual line 模式.
"             ctrl v  进入 visual block 模式.
"                  o  使光标在选择范围的开头和结尾来回跳转.
"
" ** 分屏
"            :sp/:vs  上下/左右 分割窗口.
"       :sp/:vs file  上下/左右 分屏创建新文件.
"            ctrl ww  光标在多个分屏窗口之间移动.
"     ctrl w j/k/h/l  光标移动到 下面/上面/左边/右边 的窗口.
"              :only  多个分屏窗口的场景下, 使用此命令仅保留当前光标所在窗口, 关闭所有其他窗口.

" ** 其他:
"              :help  顶部分屏打开帮助文档窗口.
"            :%s/2/3  将所有行的2替换为3, 命令行模式下这种方式替换字符串时, 会实时高亮显示要替换的字符串.
"                 :x  保存并退出, 和`:wq`一个意思.
"                 :q  关闭窗口.
"                 :!  后面输入要执行的系统命令, 回车执行.
"                  .  重复执行最近一次的修改动作.
"                  /  正向搜索模式.
"                  ?  反向搜索模式.
"                n/N  配合上面两个命令, 正向/方向跳转到搜索关键字.
"             ctrl g  显示光标所在文件的全路径, 当前文件一共多少行, 光标所在行是当前文件的百分之多少的位置.
"
" }}

"""""""""" VIM 插件提供的部分能力 {{
"
" ** dense-analysis/ale (https://github.com/dense-analysis/ale)
"                 :w  保存代码文件的时候, 将自动检查语法错误并提示.
"           ctrl k/j  向上或向下跳转到下一个错误提示的位置.
"
" ** ycm-core/YouCompleteMe (https://github.com/ycm-core/YouCompleteMe)
"                  K  顶部分屏的方式, 查看光标所在模块或函数的帮助文档.
"                 ,D  浮现光标所在对象的对应文档.
"                 gd  跳转到光标所在函数的定义位置, `ctrl o`跳转回来, `ctrl i`再跳转过去.
"                 gr  跳转到引用光标所在函数的位置, 同样使用`ctrl o/i`来回跳转.
"             ctrl l  编写各种主流语言代码时, 输入1个字符时就会自动有代码补全提示,
"                     也可使用`ctrl l`主动触发语义补全提示, 然后按tab键进行选择.
"
" ** Yggdroot/LeaderF (https://github.com/Yggdroot/LeaderF)
"                 ff  进入文件搜索的 模糊搜索 方式;
"             ctrl r  在 ff 命令的基础上, 按这个快捷键进入文件搜索的 正则匹配 方式;
"                ,fm  显示最近打开过的文件列表.
"                ,ft  显示当前文件的 tags 列表.
"                ,fl  显示当前文件的去除空行的所有行.
"                 rg  1) 从 normal 模式下按 rg 进入命令行模式下, 然后输入要搜索的文本(支持正则表达式),
"                        回车即可显示此项目内包含此文本的文件列表;
"                        在弹出的结果窗口中, 按 gi 可以将光标移动到输入框, 可以继续输入内容缩小结果列表,
"                        然后按 tab 进入结果列表中, 按 j/k 上下选择, 选择一个文件后,
"                        按 t 将以新建标签页的方式打开选择的文件.
"                     2) 可视模式下选择文本后, 按 rg 在整个项目内搜索选择的文本, 显示搜索结果.

"                 rc  rg 搜索内容关闭后, 想再次搜索上次是搜索的内容, 普通模式下按 rc 即可.
"
" ** preservim/nerdcommenter (https://github.com/preservim/nerdcommenter)
"          ,c<space>  注释或取消注释光标所在行, 或可视模式下选择多行来注释或取消注释.
"                ,cc  只注释, 如果原来就有注释则多一层注释.
"
" ** easymotion/vim-easymotion (https://github.com/easymotion/vim-easymotion)
"                ,,w  把光标下方的所有可见内容进行高亮符号标记, 想让光标跳转到哪里,
"                     就输入那里的高亮字符或字符组合, 即可跳转到那里.
"
" ** fatih/vim-go (https://github.com/fatih/vim-go/wiki/Tutorial) 只适用于Go
"                 ,i  窗口底部显示光标所在函数等的简要信息.
"                 ,d  顶部分屏显示光标所在函数等的文档.
"                ,dv  左侧分屏查看光标所在函数等的文档.
"                 ,s  查看光标所在的类型实现了哪些接口, 注意光标只能在类型或类型的方法上.
"                 ,f  查看哪些地方调用了光标所在的函数.
"                 ,t  go test 测试当前go文件.
"                 ,c  查看当前文件的测试覆盖率.
"                 ,r  go run 运行当前go文件.
"                 ,b  go build 编译当前的go文件.
"
"                 普通模式跳转到对象(函数)定义或声明处的几种方式:
"                 gd  覆盖当前页面.
"                 dt  新开一个标签页.
"                 ds  在上方分屏.
"                 dv  在右侧分屏.
"
" ** python-mode/python-mode (https://github.com/python-mode/python-mode)
"                 ,r  运行当前Python文件.
"                 ,b  添加或删除断点, 添加完成后需要在命令行来执行该Python脚本进行断点测试, 不能使用`,r`来运行.
"
" ** scrooloose/nerdtree (https://github.com/preservim/nerdtree)
"                 ,w  打开或关闭左侧目录树.
"                  q  关闭目录树窗口.
"                  ?  打开/关闭该插件的帮助文档.
"                o/O  展开目录/递归的展开目录, 原地再按一次则对应关闭目录.
"                x/X  闭合目录/闭合递归展开的目录, 进行此操作时, 光标应该在要闭合的目录中.
"                t/T  以标签页形式打开/静默打开文件, 如果光标在空目录上则新创建一个空文件并打开,
"                     然后使用`:w newfilename`来保存文件, 最后 r 来更新左侧目录树的显示.
"              gt/gT  向右/向左切换标签页.
"                3gt  切换到第3个标签, 切换到其他标签的方法类似.
"          shift l/h  向右/向左切换标签页, 是在.vimrc中配置的上一条快捷键的映射.
"          3 shift l  切换到第3个标签.
"                  R  变更目录名称后, 更新目录树中的目录显示.
"                 CD  如果当前目录树的根目录包含了很多项目, 如果要将某个项目设置为目录树的根,
"                     则选择这个项目目录, 按`CD`.
"                 go  选择一个文件, 按`go`, 只是在当前窗口展示这个文件的内容, 光标还停留在目录树窗口.
"                  I  显示/隐藏以 . 开头的文件.
"                  m  光标移动到某个文件或目录, 按`m`, 展示可操作的menu列表, 选择你要的操作,
"                     比如删除/添加/移动文件或目录等, 使用 ESC 中途退出操作.
"
" ** majutsushi/tagbar (https://github.com/preservim/tagbar)
"                 ,e  打开右侧大纲窗口.
"
" ** tpope/vim-surround (https://github.com/tpope/vim-surround)
"               ysw"  使光标所在单词使用`"`包裹, 不包括光标前的字符.
"              ysiw"  光标所在的完整单词使用`"`包裹, 包括光标前的字符.
"              ysiW"  以空格作为分隔符来作为单词, 特殊符号也可以作为单词的一部分了.
"              ys3w"  以光标所在位置为起始位置向右的3个单词使用`"`包裹.
"               yss"  以光标所在行为单位包裹.
"                ds"  删除光标周围的双引号.
"               cs"'  把光标所在周围的双引号替换为单引号.
"               cst'  将类似 <div>hello world</div> 变为 'hello world'.
"
" ** kien/ctrlp.vim (https://github.com/kien/ctrlp.vim)
"             ctrl p  将在当前窗口下面列出当前打开文件根目录下的所有文件.
"           ctrl k/j  在列出的文件中向上或向下选择文件.
"             ctrl t  在新标签页中打开选中文件.
"           ctrl x/v  水平和垂直切分打开选中文件.
"              enter  覆盖当前页面的方式打开选中文件.
"
" ** mattn/emmet-vim (https://raw.githubusercontent.com/mattn/emmet-vim/master/TUTORIAL)
"           ctrl y ,  打开 *.html 文件:
"                     1) 输入 html:5 然后按此快捷键, 即可自动生成html代码模版.
"                     2) 输入 div 然后按此快捷键, 即可自动生成: <div></div>
"                     3) 输入 #foo 然后按此快捷键, 可自动生成: <div id="foo"></div>
"                     4) 输入 div>p>a , 然后按此快捷键, 可自动生成: <div><p><a href=""></a></p></div>
"
" ** iamcco/markdown-preview.vim (https://github.com/iamcco/markdown-preview.vim)
"                 ,p  自动打开浏览器预览当前的 .md Markdown文件.
"                ,pp  关闭浏览器中的打开的预览.
" }}

"""""""""" VIM 实例练习 {{
"
" ** 将`one two three four five six`改为`"one","two","four","five","six"`
"                  ^  光标移动到第一个非空字符.
"           f<space>  光标移动到第一个空格.
"                 cl  删除1个空格并进入到 insert 模式, 输入 ",", 按 ESC 进入到 normal 模式.
"                  ;  光标跳转到下一个空格.
"                  .  重复执行步骤3, 然后 ; 和 . 重复多次直到将所有空格都替换成 ",".
"                  I  将光标跳转到行首并进入到 insert 模式, 输入 ", 按 ESC 进入到 normal 模式.
"                  A  将光标跳转到行尾并进入到 insert 模式, 输入 ", 按 ESC 进入到 normal 模式.
"
" ** 把文件内的某个连续的行尾/或行首加上`,`:
"             ctrl v  进入 visual block 模式, 选择要操作的那些连续行.
"                  $  移动到行尾.
"                I/A  进入 insert 模式, 光标在 行首/行尾, 输入要增加的字符 `,`.
"            ESC ESC  连续按2次 ESC 即可.
"
" ** 将多行合并成1行:
"         v/V/ctrl v  进入 visual 或 visual line 或 visual block 模式.
"                J  合并成1行.
"
" ** 本地编辑器之间的复制和粘贴:
"       [n]yy / Y 或 v 选择文本使用y复制等复制命令需要的文本对象, 此时默认已复制到本地系统剪贴板,
"       可在本文件、其他 VIM 实例文件普通模式下按 p/P 来粘贴, 或插入模式下`command v`粘贴,
"       或操作系统上的任何文本框内进行`command v`粘贴.
"
" ** 通过 SSH 远程管理的 Linux 系统下使用 VIM 时的复制和粘贴:
"       远程 Linux 系统 VIM 实例普通模式下(适用于使用termimal, 如果是iterm2则任何模式均可),
"       需要使用鼠标(或option+command+鼠标)选择文本,
"       通过`command c`(本地是macOS系统)将选中文本复制到 macOS 本地的剪贴板,
"       最后通过`command v`粘贴到本地各应用的文本输入框.
"
" ** 宏的使用方法举例, 比如给文本的每一行的行首和行尾都加上双引号:
"       普通模式下`qa`, q 是宏指令, 表明开始录制宏, a 为宏的名称, 可以是 a-z 的任何字母,
"       然后我们给一行的行首和行尾都加上双引号,
"       最后普通模式下`q`, 表示结束宏的录制;
"       接下来我们把这个宏 a 运用在每一行上, 我们选择文本所有的行, 然后命令行方式`: normal @a`,
"       或者`:% normal @a`(%表示所有行), 这样所有行就都完成双引号包裹了.
"
" }}

" }}
